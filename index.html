<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Zoomable Draggable Squares</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- interact.js v1 -->
    <script src="https://cdn.jsdelivr.net/npm/interactjs@1.10.11/dist/interact.min.js"></script>

    <style>
        /* floating animation */
        @keyframes float {

            0%,
            100% {
                transform: translateY(0)
            }

            50% {
                transform: translateY(-8px)
            }
        }

        .floating {
            animation: float 3s ease-in-out infinite;
        }

        /* .box {
            transition: left 0.3s ease, top 0.3s ease;
        } */
        /* only boxes with this class will animate their left/top */
        .group-transition {
            transition: left 0.3s ease, top 0.3s ease;
        }

        /* scale only the inner container */
        #container {
            transform-origin: top left;
            /*transition: transform 0.2s ease-out;*/
            /* animate transform, width and height over 300ms with ease-in-out */
            transition: transform 0.05s ease-in-out,
                width 0.05s ease-in-out,
                height 0.05s ease-in-out;
            padding-top: 10rem;
        }

        /* highlight selected boxes */
        .box.selected {
            outline: 2px solid #88f;
            outline-offset: 2px;
        }

        /* highlight locked boxes */
        .box.locked {
            outline: 2px solid rgb(255, 3, 74);
            outline-offset: 2px;
        }

        /* selection rectangle */
        .select-rect {
            position: absolute;
            border: 1px dashed white;
            background-color: rgba(255, 255, 255, 0.1);
            pointer-events: none;
            z-index: 10;
        }

        .sel-count-label {
            position: absolute;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.875rem;
            pointer-events: none;
            z-index: 11;
        }
    </style>
</head>

<body class="overflow-hidden bg-gray-900 min-h-screen p-2 flex items-center justify-center">

    <!-- zoom controls -->
    <div class="absolute top-4 right-4 flex space-x-2 z-20">
        <button id="zoom-in" class="bg-gray-700 text-white px-3 py-1 rounded shadow hover:bg-gray-600">+</button>
        <button id="zoom-out" class="bg-gray-700 text-white px-3 py-1 rounded shadow hover:bg-gray-600">–</button>
        <button id="group-btn" class="bg-gray-700 text-white px-3 py-1 rounded shadow hover:bg-gray-600">
            Group
        </button>
    </div>

    <!-- new: vertical slider, 1rem below the buttons -->
    <div class="absolute" style="top: 7rem; right: -2rem; z-index:20;">
        <input id="zoom-slider" type="range" min="0.2" max="1.5" step="0.01" value="1"
            class="w-32 h-2 -rotate-90 origin-center" />
    </div>


    <div class="absolute top-4 left-4 flex space-x-2 z-20">
        <!-- bg-green-600 text-white px-3 py-1 rounded shadow hover:bg-green-500-->
        <button id="add-square" class="bg-gray-700 text-white px-3 py-1 rounded shadow hover:bg-gray-600">
            Add Square
        </button>
        <button id="copy-btn" class="bg-gray-700 text-white px-3 py-1 rounded shadow hover:bg-gray-600">
            Copy
        </button>
        <button id="delete-btn" class="bg-gray-700 text-white px-3 py-1 rounded shadow hover:bg-gray-600">
            Delete
        </button>
        <button id="lock-btn" class="bg-gray-700 text-white px-3 py-1 rounded shadow hover:bg-gray-600">
            Lock
        </button>
    </div>


    <div class="absolute bottom-4 left-4 z-20">
        <div class="bg-gray-700 text-white px-3 py-2 rounded shadow w-48">
            <!-- centered bold title -->
            <div class="font-bold text-center text-lg mb-2 underline underline-offset-[6px]">
                INFO
            </div>
            <!-- your existing bullets -->
            <p class="text-sm leading-snug">
                • Drag to select multiple squares.<br>
                • Use Group to align into a grid.<br>
                • Click Delete to remove selected.<br>
                • Use Copy to duplicate below.
            </p>
        </div>
    </div>

    <!-- outer panel -->
    <div id="panel" class="flex flex-col
w-full h-[calc(100vh-16px)] max-w-[calc(100vw-16px)]
bg-gray-800 rounded-lg border-2 border-gray-700
overflow-visible">


        <h1 class="text-3xl text-white font-bold text-center py-1 underline underline-offset-[6px]">
            Scale Tool
        </h1>


        <!-- zooms here -->
        <div id="container" class="relative flex-1 overflow-visible">
            <!-- boxes injected here -->
        </div>
    </div>


    <!--********************** JAVASCRIPT*****************************************************-->
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // keep track of clusters the user has “locked” by clicking their badge
            const lockedBoxes = new Set();

            const panel = document.getElementById('panel');
            const container = document.getElementById('container');
            const COUNT = 9;
            const SIZE = 96;   // px
            const GAP = 16;   // px WIP
            let zoomLevel = 1.0;

            function repositionCountLabel() {
                const lbl = container.querySelector('.sel-count-label');
                if (!lbl) return;

                const selectedEls = Array.from(container.querySelectorAll('.box.selected'));
                if (!selectedEls.length) {
                    lbl.remove();
                    return;
                }

                const xs = selectedEls.map(el => +el.dataset.x);
                const ys = selectedEls.map(el => +el.dataset.y);
                const minX = Math.min(...xs);
                const maxX = Math.max(...xs) + SIZE;
                const minY = Math.min(...ys);

                const labelX = minX + (maxX - minX) / 2;
                const labelY = minY - 50;

                lbl.style.left = `${labelX}px`;
                lbl.style.top = `${labelY}px`;
                lbl.style.transform = `translateX(-50%) scale(${1 / zoomLevel})`;
            }

            // 1) create boxes (blank)
            for (let i = 0; i < COUNT; i++) {
                const box = document.createElement('div');
                box.className = [
                    'box', 'absolute', 'w-24', 'h-24',
                    'bg-gray-700', 'rounded-lg', 'shadow-lg',
                    'cursor-move'
                ].join(' '); // 'floating'
                const startX = 16 + i * (SIZE + 16),
                    startY = 80;
                box.style.left = startX + 'px';
                box.style.top = startY + 'px';
                box.dataset.x = startX;
                box.dataset.y = startY;
                // random float phase
                //box.style.animationDelay = `-${Math.random()*3}s`;
                container.appendChild(box);
            }

            // helper: create a new box at (x,y) and hook up dragging
            function createBox(x, y) {
                const box = document.createElement('div');
                box.className = [
                    'box', 'absolute', 'w-24', 'h-24',
                    'bg-gray-700', 'rounded-lg', 'shadow-lg',
                    'cursor-move'
                ].join(' ');
                box.style.left = x + 'px';
                box.style.top = y + 'px';
                box.dataset.x = x;
                box.dataset.y = y;
                box.style.animationDelay = `-${Math.random() * 3}s`;
                container.appendChild(box);

                // 3) mark it selected
                box.classList.add('selected');
                //interact(box).draggable(dragConfig);
            }

            // 2) selection‐rectangle (scaled!)
            let isSelecting = false,
                selDiv = null,
                selStart = { x: 0, y: 0 };

            function clearSelection() {
                // only un-select boxes that aren't locked
                container.querySelectorAll('.box.selected').forEach(el => {
                    if (!lockedBoxes.has(el)) {
                        el.classList.remove('selected');

                        // remove any old count‐labels
                        container.querySelectorAll('.sel-count-label')
                            .forEach(el => el.remove());
                    }
                });
                // 1) clear any prior inSelection flags
                container.querySelectorAll('.box.inSelection')
                    .forEach(el => el.classList.remove('inSelection'));


            }

            function renderClusterLabels() {
                // 1) clear old labels
                container.querySelectorAll('.sel-count-label')
                    .forEach(lbl => lbl.remove());

                // 2) grab current selected boxes
                const els = Array.from(container.querySelectorAll('.box.selected'));
                if (!els.length) return;

                // 3) union-find to cluster by proximity (≤ SIZE+20px both axes)
                const n = els.length;
                const parent = [...Array(n).keys()];
                function find(i) { return parent[i] === i ? i : parent[i] = find(parent[i]); }
                function union(a, b) { parent[find(b)] = find(a); }

                for (let i = 0; i < n; i++) {
                    const xi = +els[i].dataset.x, yi = +els[i].dataset.y;
                    for (let j = i + 1; j < n; j++) {
                        const xj = +els[j].dataset.x, yj = +els[j].dataset.y;
                        if (Math.abs(xi - xj) <= SIZE + 20 && Math.abs(yi - yj) <= SIZE + 20) {
                            union(i, j);
                        }
                    }
                }

                // 4) bucket into groups
                const groups = {};
                for (let i = 0; i < n; i++) {
                    const r = find(i);
                    (groups[r] ||= []).push(els[i]);
                }

                // 5) for each group, append a label
                Object.values(groups).forEach(cluster => {
                    // compute bounding‐box of this cluster
                    const xs = cluster.map(el => +el.dataset.x),
                        ys = cluster.map(el => +el.dataset.y);
                    const minX = Math.min(...xs),
                        maxX = Math.max(...xs) + SIZE,
                        minY = Math.min(...ys);

                    const lbl = document.createElement('div');
                    lbl.className = [
                        'sel-count-label',
                        'bg-gray-700', 'text-white', 'px-2', 'py-1',
                        'rounded', 'shadow', 'pointer-events-none', 'z-20'
                    ].join(' ');
                    lbl.textContent = cluster.length;

                    // position & cancel zoom
                    const labelX = minX + (maxX - minX) / 2;
                    const labelY = minY - 50;
                    lbl.style.left = `${labelX}px`;
                    lbl.style.top = `${labelY}px`;
                    lbl.style.transformOrigin = 'center bottom';
                    lbl.style.transform = `translateX(-50%) scale(${1 / zoomLevel})`;

                    container.appendChild(lbl);
                });
            }


            container.addEventListener('mousedown', e => {
                if (e.button !== 0 || e.target !== container) return;

                isSelecting = true;
                console.log('iselecting:', isSelecting);
                const crect = container.getBoundingClientRect();

                // ↓ Adjust start to container‐local, unscaled coords
                selStart.x = (e.clientX - crect.left) / zoomLevel;
                selStart.y = (e.clientY - crect.top) / zoomLevel;

                selDiv = document.createElement('div');
                selDiv.className = 'select-rect';
                selDiv.style.left = selStart.x + 'px';
                selDiv.style.top = selStart.y + 'px';
                selDiv.style.width = '0px';
                selDiv.style.height = '0px';
                container.appendChild(selDiv);

                clearSelection();
                window.addEventListener('mousemove', updateSelectRect);
                window.addEventListener('mouseup', finishSelectRect);
            });

            function updateSelectRect(e) {
                if (!isSelecting) return;
                const crect = container.getBoundingClientRect();

                // ↓ Compute current point in container coords, dividing out zoom
                const curX = (e.clientX - crect.left) / zoomLevel;
                const curY = (e.clientY - crect.top) / zoomLevel;

                const x1 = Math.min(selStart.x, curX),
                    y1 = Math.min(selStart.y, curY),
                    x2 = Math.max(selStart.x, curX),
                    y2 = Math.max(selStart.y, curY);

                selDiv.style.left = x1 + 'px';
                selDiv.style.top = y1 + 'px';
                selDiv.style.width = (x2 - x1) + 'px';
                selDiv.style.height = (y2 - y1) + 'px';
            }

            function finishSelectRect(e) {
                if (!isSelecting) return;
                isSelecting = false;
                window.removeEventListener('mousemove', updateSelectRect);
                window.removeEventListener('mouseup', finishSelectRect);

                // get the selection‐rectangle bounds
                const rectX = parseFloat(selDiv.style.left),
                    rectY = parseFloat(selDiv.style.top),
                    rectW = parseFloat(selDiv.style.width),
                    rectH = parseFloat(selDiv.style.height);

                const selB = selDiv.getBoundingClientRect();
                selDiv.remove(); selDiv = null;

                // 1) clear any prior inSelection flags
                container.querySelectorAll('.box.inSelection')
                    .forEach(el => el.classList.remove('inSelection'));

                container.querySelectorAll('.box').forEach(el => {

                    const r = el.getBoundingClientRect();
                    if (r.left < selB.right && r.right > selB.left &&
                        r.top < selB.bottom && r.bottom > selB.top) {

                        el.classList.add('selected', 'inSelection');
                    }
                });

                // 2) compute bounding‐box of selected boxes in container coords
                const selectedEls = Array.from(container.querySelectorAll('.box.selected'));
                if (selectedEls.length) {
                    renderClusterLabels();
                }
            }

            // 3) draggable + group‐drag (unchanged)
            let groupDrag = false, selectedEls = [], initPos = [], delta = { x: 0, y: 0 };
            interact('.box').draggable({
                inertia: true,
                modifiers: [
                    interact.modifiers.restrictRect({
                        restriction: panel,
                        endOnly: false,
                        elementRect: { top: 0, left: 0, bottom: 1, right: 1 }
                    })
                ],
                onstart(event) {
                    const t = event.target;

                    let one = false;
                    let lockDrag = false;
                    if (!t.classList.contains('selected') && !t.classList.contains('locked')) {
                        clearSelection();
                        t.classList.add('selected');
                        one = true;
                    }

                    if (t.classList.contains('locked')) {
                        clearSelection();
                        //t.classList.add('selected');
                        lockDrag = true;
                    }


                    // 1) Grab only the boxes you just rectangle-selected:
                    //    (we’re assuming finishSelectRect painted them with .inSelection)
                    let rectSel = Array.from(
                        container.querySelectorAll('.box.inSelection')
                    );

                    console.log('rectSel length:', rectSel.length);
                    //let noSelect = false;
                    if (rectSel.length == 0) {
                        rectSel = Array.from(
                            container.querySelectorAll('.box.selected')
                        );
                        //noSelect = true;
                    }

                    // 2) Split that into locked vs unlocked:
                    const locked = rectSel.filter(el => lockedBoxes.has(el));
                    const unlocked = rectSel.filter(el => !lockedBoxes.has(el));

                    // 3) Decide which group to actually drag:
                    let toDrag;
                    console.log('unlock length:', unlocked.length);
                    console.log('one:', one);
                    /* if (noSelect && (unlocked.length == 1)) {
                        toDrag = unlocked;
                        console.log('active');
                    } */
                    if (one) {
                        toDrag = unlocked;
                        console.log('one active');
                    }
                    else if (lockDrag) {
                        toDrag = locked;
                        console.log('lockdrag active');
                    }
                    else if (locked.length === rectSel.length) {
                        // you dragged *only* locked boxes
                        toDrag = locked;
                        console.log('locked active');
                    }
                    else if (unlocked.length === rectSel.length) {
                        // you dragged *only* unlocked (freshly selected) boxes
                        console.log('unlocked active');
                        toDrag = unlocked;
                    }
                    else {
                        // mixed → drag everything you hit
                        console.log('mixed/all active');
                        toDrag = rectSel;
                    }

                    // 4) Build your initPos from *that* array:
                    currentInit = toDrag.map(el => ({
                        el,
                        x: parseFloat(el.dataset.x),
                        y: parseFloat(el.dataset.y),
                    }));
                    /* selectedEls = Array.from(container.querySelectorAll('.box.selected'));
                    selectedElsLocked = Array.from(container.querySelectorAll('.box.locked')); //could also use: const allLocked = Array.from(lockedBoxes);
                    selectedElsNotLocked = Array.from(container.querySelectorAll('.box.selected:not(.locked)'));

                    const lockedCount = selectedEls.filter(el => lockedBoxes.has(el)).length;
                    const totalCount = selectedEls.length;

                    initPos = selectedEls.map(el => ({
                        el, x: parseFloat(el.dataset.x), y: parseFloat(el.dataset.y)
                    }));
                    initPosLocked = selectedElsLocked.map(el => ({
                        el, x: parseFloat(el.dataset.x), y: parseFloat(el.dataset.y)
                    }));
                    initPosNotLocked = selectedElsNotLocked.map(el => ({
                        el, x: parseFloat(el.dataset.x), y: parseFloat(el.dataset.y)
                    }));

                    const allLocked = (lockedCount === totalCount);
                    const allUnlocked = (lockedCount === 0);
                    const mixed = !allLocked && !allUnlocked;

                    // now you can branch on the three states:
                    if (allLocked) {
                        // only locked boxes were selected
                        currentInit = initPosLocked;
                    }
                    else if (allUnlocked) {
                        // only freshly‐selected (unlocked) boxes
                        currentInit = initPosNotLocked;
                    }
                    else { //mixed
                        // both kinds in the same drag‐select
                        currentInit = initPos;
                    } */

                    delta = { x: 0, y: 0 };
                    groupDrag = selectedEls.length > 1;
                    //groupDrag = true;
                },
                onmove(event) {
                    const dx = event.dx / zoomLevel, dy = event.dy / zoomLevel;
                    delta.x += dx; delta.y += dy;

                    currentInit.forEach(item => {
                        const nx = item.x + delta.x, ny = item.y + delta.y;
                        item.el.style.left = nx + 'px';
                        item.el.style.top = ny + 'px';
                        item.el.dataset.x = nx;
                        item.el.dataset.y = ny;
                    });

                    renderClusterLabels();
                }
            });

            // 4) zoom logic (updated)
            const { width: origW, height: origH } = container.getBoundingClientRect();

            function applyZoom() {
                // scale the visuals
                container.style.flex = 'none';
                container.style.transform = `scale(${zoomLevel})`;
                // grow/shrink the raw box so its hit‐area stays constant
                container.style.width = `${origW / zoomLevel}px`;
                container.style.height = `${origH / (zoomLevel)}px`;

                // 2) update every count‐label so it stays constant in screen-space
                container.querySelectorAll('.sel-count-label').forEach(lbl => {
                    // we already set transformOrigin to 'center bottom' when we created it
                    lbl.style.transform = `translateX(-50%) scale(${1 / zoomLevel})`;
                });
            }

            document.getElementById('zoom-in').onclick = () => {
                zoomLevel = Math.min(2, zoomLevel + 0.1);
                applyZoom();
            };
            document.getElementById('zoom-out').onclick = () => {
                zoomLevel = Math.max(0.3, zoomLevel - 0.1);
                applyZoom();
            };


            // initialize on load
            applyZoom();

            // grab the new button
            const groupBtn = document.getElementById('group-btn');

            groupBtn.addEventListener('click', () => {
                // find all selected boxes
                const selected = Array.from(container.querySelectorAll('.box.selected:not(.locked)'));
                const n = selected.length;
                if (n === 0) return;


                // 1) add the transition class
                selected.forEach(el => el.classList.add('group-transition'));

                // 2) force the browser to notice the class before we move them
                //    so the transition actually runs:
                selected[0].offsetWidth; // reflow

                // 1) compute grid dimensions
                const cols = Math.ceil(Math.sqrt(n));       // e.g. sqrt(7)=2.64→3 columns
                const rows = Math.ceil(n / cols);           // fill rows of that many cols
                const GAP = 16;                            // same gap you used when laying out
                const SIZE = 96;                            // your box size

                // 2) compute the “center” of the current selection
                const sum = selected.reduce((s, el) => ({
                    x: s.x + parseFloat(el.dataset.x),
                    y: s.y + parseFloat(el.dataset.y)
                }), { x: 0, y: 0 });

                const centerX = sum.x / n;
                const centerY = sum.y / n;

                // 3) figure out total pixel dimensions of the new grid
                const totalW = (cols - 1) * (SIZE + GAP);
                const totalH = (rows - 1) * (SIZE + GAP);

                // 4) pick a start-point so that the grid’s center sits at (centerX, centerY)
                const startX = centerX - totalW / 2;
                const startY = centerY - totalH / 2;

                // 5) re-position each box into its [row, col] slot
                selected.forEach((el, i) => {
                    const row = Math.floor(i / cols);
                    const col = i % cols;
                    const x = startX + col * (SIZE + GAP);
                    const y = startY + row * (SIZE + GAP);

                    el.style.left = x + 'px';
                    el.style.top = y + 'px';
                    el.dataset.x = x;
                    el.dataset.y = y;
                });

                // 4) after the animation duration, strip the class so future drags are instant
                setTimeout(() => {
                    selected.forEach(el => el.classList.remove('group-transition'));
                }, 300); // match the 0.3s in your CSS

                // Remove any existing count‐labels
                //container.querySelectorAll('.sel-count-label')
                //        .forEach(lbl => lbl.remove());

                //clearSelection();
                renderClusterLabels();
            });


            // 6) **ADD SQUARE** button
            document.getElementById('add-square')
                .addEventListener('click', () => {
                    const selected = Array.from(container.querySelectorAll('.box.selected'));
                    let x, y;

                    if (selected.length > 0) {
                        // find the SW-most selected box
                        const sw = selected.reduce((best, el) => {
                            const ex = parseFloat(el.dataset.x),
                                ey = parseFloat(el.dataset.y);
                            const bx = parseFloat(best.dataset.x),
                                by = parseFloat(best.dataset.y);
                            // pick the one with larger y (lower on screen),
                            // and if tie, the smaller x (more to the left)
                            if (ey > by || (ey === by && ex < bx)) return el;
                            return best;
                        }, selected[0]);

                        x = parseFloat(sw.dataset.x);
                        y = parseFloat(sw.dataset.y) + SIZE + GAP;  // directly below
                    } else {
                        // fallback: top-left if nothing selected
                        x = 16;
                        y = 80;
                    }

                    createBox(x, y);
                });

            const slider = document.getElementById('zoom-slider');

            // whenever the slider moves, set zoomLevel and redraw
            slider.addEventListener('input', e => {
                zoomLevel = parseFloat(e.target.value);
                applyZoom();
            });

            // keep the slider in sync when + / – buttons are clicked:
            function updateSlider() {
                slider.value = zoomLevel.toFixed(2);
            }



            document.getElementById('copy-btn').addEventListener('click', () => {
                const selected = Array.from(container.querySelectorAll('.box.selected'));
                if (selected.length === 0) return;

                // find SW-most selected box
                const sw = selected.reduce((best, el) => {
                    const ex = +el.dataset.x, ey = +el.dataset.y;
                    const bx = +best.dataset.x, by = +best.dataset.y;
                    return (ey > by || (ey === by && ex < bx)) ? el : best;
                }, selected[0]);

                const swX = +sw.dataset.x,
                    swY = +sw.dataset.y;

                // compute each box’s offset from SW
                const deltas = selected.map(el => ({
                    dx: +el.dataset.x - swX,
                    dy: +el.dataset.y - swY
                }));

                // new group’s origin — directly below SW
                const baseX = swX,
                    baseY = swY + SIZE + GAP;

                // clear old selection, then paste copies
                clearSelection();
                container.querySelectorAll('.sel-count-label')
                    .forEach(lbl => lbl.remove());
                //repositionCountLabel();

                deltas.forEach(delta => {
                    createBox(baseX + delta.dx, baseY + delta.dy);
                });
            });

            document.getElementById('delete-btn').addEventListener('click', () => {
                // remove all selected boxes
                container.querySelectorAll('.box.selected').forEach(el => el.remove());
                // clear any selection state and count-label
                clearSelection();
            });

            document.getElementById('lock-btn').addEventListener('click', () => {
                const selected = Array.from(container.querySelectorAll('.box.selected'));
                selected.forEach(box => {
                    if (lockedBoxes.has(box)) {
                        // it’s already locked → unlock it
                        lockedBoxes.delete(box);
                        box.classList.remove('locked');
                    } else {
                        // not locked yet → lock it
                        lockedBoxes.add(box);
                        box.classList.add('locked');
                    }
                });
                clearSelection();
                //console.log('Locked boxes count:', lockedBoxes.size);
            });


        });
    </script>
</body>

</html>
