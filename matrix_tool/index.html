<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>DatVis Tool Suite</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- interact.js v1 -->
    <script src="https://cdn.jsdelivr.net/npm/interactjs@1.10.11/dist/interact.min.js"></script>
    <style>
      /* floating animation */
      @keyframes float {
        0%,
        100% {
          transform: translateY(0);
        }

        50% {
          transform: translateY(-8px);
        }
      }

      /* Overlay styles */
      .landing-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1000;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: rgba(0, 0, 0, 0.2);
        backdrop-filter: blur(8px);
        transition: opacity 0.5s ease, visibility 0.5s ease;
      }

      /* Content box styles */
      .landing-content {
        background-color: #1f2937; /* Dark background to match theme */
        color: white;
        padding: 2.5rem;
        border-radius: 0.75rem;
        max-width: 500px;
        text-align: center;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
        border: 1px solid #374151;
      }

      .landing-content h1 {
        font-size: 2rem;
        margin-bottom: 1rem;
      }

      .landing-content p {
        margin-bottom: 1.5rem;
        color: #d1d5db;
      }

      .landing-buttons {
        display: flex;
        justify-content: center;
        gap: 1rem;
      }

      .landing-button {
        background-color: #374151;
        color: white;
        border: none;
        padding: 0.75rem 1.5rem;
        border-radius: 0.5rem;
        font-size: 1rem;
        cursor: pointer;
        transition: background-color 0.2s ease;
      }

      .landing-button:hover {
        background-color: #4b5563;
      }

      .landing-button.primary {
        background-color: #3b82f6;
      }

      .landing-button.primary:hover {
        background-color: #2563eb;
      }

      /* Hide overlay when dismissed */
      .landing-overlay.hidden {
        opacity: 0;
        visibility: hidden;
        pointer-events: none;
      }

      /* make each box a flex‐container centered both ways */
      .box {
        display: flex;
        align-items: center;
        justify-content: center;
      }

      /* style the label and prevent it from catching pointer events */
      .box-label {
        pointer-events: none;
        user-select: none;
        color: white;
        font-size: 3rem;
      }

      /* style the inner input to sit in the center */
      .box-input {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 50%; /* adjust to taste */
        background: transparent;
        border: 1px solid #88f;
        border-radius: 4px;
        border-width: 2px;
        color: white;
        text-align: center;
        font-size: 2rem;
        outline: none;
        pointer-events: auto; /* so you can type in it */
      }

      /* hide the border and block pointer-events when disabled */
      .box-input.disabled {
        border: 1px solid #888;
        pointer-events: none !important;
      }

      .floating {
        animation: float 3s ease-in-out infinite;
      }

      /* .box {
            transition: left 0.3s ease, top 0.3s ease;
        } */
      /* only boxes with this class will animate their left/top */
      .group-transition {
        transition: left 0.3s ease, top 0.3s ease;
      }

      .transpose-transition {
        transition: left 1s ease, top 1s ease;
      }

      /* scale only the inner container */
      #container {
        transform-origin: top left;
        /*transition: transform 0.2s ease-out;*/
        /* animate transform, width and height over 300ms with ease-in-out */
        transition: transform 0.05s ease-in-out, width 0.05s ease-in-out,
          height 0.05s ease-in-out;
        padding-top: 10rem;
      }

      /* highlight selected boxes */
      .box.selected {
        outline: 2px solid #88f;
        outline-offset: 2px;
      }

      /* highlight locked boxes */
      .box.locked {
        outline: 2px solid rgb(255, 3, 74);
        outline-offset: 2px;
      }

      /* selection rectangle */
      .select-rect {
        position: absolute;
        border: 1px dashed white;
        background-color: rgba(255, 255, 255, 0.1);
        pointer-events: none;
        z-index: 10;
      }

      .box.locked.inSelection {
        outline: 2px dashed rgb(255, 3, 74);
        outline-offset: 2px;
      }

      .sel-count-label {
        position: absolute;
        background: rgba(0, 0, 0, 0.6);
        color: white;
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 0.875rem;
        pointer-events: none;
        z-index: 11;
      }

      /* #legend {
        border: 1px solid #888;
        border-radius: 0.5rem;
        overflow: hidden;
      } */
      /* 1) give the tutorial window a border and rounded corners */
      #tutorial {
        border: 1px solid #888; /* or whatever color */
        border-radius: 0.5rem; /* match your header/body rounding */
        overflow: hidden; /* clip child corners */
        /* 2) animate size changes */
        transition: max-width 0.1s ease, max-height 0.1s ease, width 0.1s ease,
          height 0.1s ease;
      }

      /* anywhere in your stylesheet */
      #tutorial.ui-control:hover {
        opacity: 1 !important;
        pointer-events: all; /* so you can still interact with it */
      }

      #tutorial.ui-control {
        /* this selector is more specific than #tutorial, so it wins */
        transition: opacity 0.4s ease-in-out;
      }

      /* hide full text by default */
      #tutorial-content-full {
        display: none;
      }

      /* COLLAPSED: show only the “min” content */
      #tutorial.collapsed #tutorial-content-min {
        display: block;
      }
      #tutorial.collapsed #tutorial-content-full {
        display: none;
      }

      /* EXPANDED: show only the “full” content */
      #tutorial.expanded #tutorial-content-min {
        display: none;
      }
      #tutorial.expanded #tutorial-content-full {
        display: block;
      }

      /* limit the body to 50% of the viewport, and let it scroll */
      #tutorial.expanded #tutorial-body {
        max-height: 50vh;
        overflow-y: auto;
      }

      /* COLLAPSED: stays whatever its auto-width is */
      #tutorial.collapsed {
        max-width: 13rem;
      }

      /* EXPANDED: cap at 66% of viewport width */
      #tutorial.expanded {
        max-width: 66vw;
      }

      .ui-control {
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.4s ease-in-out;
      }

      .ui-control.visible {
        opacity: 1;
        pointer-events: all;
        transition-delay: 0s;
      }

      .ui-control:not(.visible) {
        transition-delay: 0s;
      }

      @keyframes flash {
        0%,
        100% {
          background-color: #374151;
        } /* normal color */
        50% {
          background-color: #526f9e;
        } /* flash color */
      }
      .flash {
        animation: flash 1s ease-in-out infinite;
      }

      #floating-tutorial {
        position: fixed;
        /* ...other styles... */
        min-width: 0 !important;
        max-width: 22rem;
        width: auto;
        /* Make the label a positioning context for the button */
        position: fixed;
      }
      #floating-tutorial {
        position: fixed;
      }
      #floating-tutorial-next {
        position: absolute;
        right: -0.1rem;
        bottom: -0.1rem;
        transform: translate(50%, 50%);
      }

      /* disable selection everywhere */
      body {
        -webkit-user-select: none; /* Chrome/Safari */
        -moz-user-select: none; /* Firefox */
        -ms-user-select: none; /* IE10+ */
        user-select: none; /* Standard */
      }

      /* but allow selecting/caret in inputs, textareas, etc. */
      input,
      textarea,
      select {
        -webkit-user-select: text;
        -moz-user-select: text;
        -ms-user-select: text;
        user-select: text;
      }
    </style>
  </head>

  <body
    class="overflow-hidden bg-gray-900 min-h-screen p-2 flex items-center justify-center"
  >
    <!-- zoom controls -->
    <div class="ui-control absolute top-4 right-4 flex space-x-2 z-20">
      <button
        id="multiply-btn"
        class="bg-gray-700 text-white px-3 py-1 rounded shadow hover:bg-gray-600"
      >
        Multiply
      </button>
      <button
        id="add-btn"
        class="bg-gray-700 text-white px-3 py-1 rounded shadow hover:bg-gray-600"
      >
        Addition
      </button>
      <button
        id="tanspose-button"
        class="bg-gray-700 text-white px-3 py-1 rounded shadow hover:bg-gray-600"
      >
        Transpose
      </button>
      <!-- <button
        id="zoom-in"
        class="bg-gray-700 text-white px-3 py-1 rounded shadow hover:bg-gray-600"
      >
        +
      </button>
      <button
        id="zoom-out"
        class="bg-gray-700 text-white px-3 py-1 rounded shadow hover:bg-gray-600"
      >
        –
      </button> -->

      <button
        id="group-btn"
        class="bg-gray-700 text-white px-3 py-1 rounded shadow hover:bg-gray-600"
      >
        Group
      </button>
    </div>

    <!-- new: vertical slider, 1rem below the buttons -->
    <div
      class="ui-control absolute"
      style="top: 7rem; right: -2rem; z-index: 20"
    >
      <input
        id="zoom-slider"
        type="range"
        min="0.2"
        max="1.5"
        step="0.01"
        value="0.6"
        class="w-32 h-2 -rotate-90 origin-center"
      />
    </div>
    <div
      class="ui-control absolute"
      style="top: 12rem; right: 1rem; z-index: 20"
    >
      <!-- Magnifying glass icon from Heroicons -->
      <svg
        xmlns="http://www.w3.org/2000/svg"
        fill="none"
        viewBox="0 0 24 24"
        stroke-width="1.5"
        stroke="currentColor"
        class="w-6 h-6 mt-2 text-gray-400"
      >
        <path
          stroke-linecap="round"
          stroke-linejoin="round"
          d="m21 21-5.197-5.197m0 0A7.5 7.5 0 1 0 5.196 5.196a7.5 7.5 0 0 0 10.607 10.607ZM10.5 7.5v6m3-3h-6"
        />
      </svg>
    </div>

    <div class="ui-control absolute top-4 left-4 flex space-x-2 z-20">
      <!-- bg-green-600 text-white px-3 py-1 rounded shadow hover:bg-green-500-->
      <button
        id="add-square"
        class="bg-gray-700 text-white px-3 py-1 rounded shadow hover:bg-gray-600"
      >
        Add Square
      </button>
      <button
        id="copy-btn"
        class="bg-gray-700 text-white px-3 py-1 rounded shadow hover:bg-gray-600"
      >
        Copy
      </button>
      <button
        id="delete-btn"
        class="bg-gray-700 text-white px-3 py-1 rounded shadow hover:bg-gray-600"
      >
        Delete
      </button>
      <button
        id="lock-btn"
        class="bg-gray-700 text-white px-3 py-1 rounded shadow hover:bg-gray-600"
      >
        Lock
      </button>
      <label
        id="edit-labels-label"
        class="flex items-center bg-gray-700 text-white px-3 py-1 rounded shadow hover:bg-gray-600 cursor-pointer"
      >
        <input type="checkbox" id="edit-labels" class="mr-2 checked" />
        Edit Labels
      </label>
    </div>

    <div class="ui-control absolute top-14 left-4 flex space-x-2 z-20">
      <!-- bg-green-600 text-white px-3 py-1 rounded shadow hover:bg-green-500-->
      <button
        id="reset-btn"
        class="bg-gray-700 text-white px-3 py-1 rounded shadow hover:bg-gray-600"
      >
        Reset
      </button>
      <button
        id="undo-btn"
        class="bg-gray-700 text-white px-3 py-1 rounded shadow hover:bg-gray-600"
      >
        Undo
      </button>
    </div>

    <!-- <div id="legend" class="ui-control absolute top-28 left-4 z-20">
      <div
        class="bg-gray-700 text-white px-3 py-2 rounded shadow w-30 space-y-1"
      >
        <div class="font-bold">Legend</div>
        <div class="flex items-center space-x-2">
          <div class="w-6 h-6 bg-gray-600 rounded border border-gray-500"></div>
          <span>=</span>

          <input
            id="block-value"
            type="number"
            value=""
            min="0"
            class="bg-gray-800 text-white rounded px-1 text-center w-12 focus:outline-none"
          />
        </div>
      </div>
    </div> -->

    <!-- <div class="absolute bottom-4 left-4 z-20">
        <button id="help-btn" class="bg-gray-700 text-white px-3 py-1 rounded shadow hover:bg-gray-600">
            HELP
        </button>
    </div> -->

    <!-- TUTORIAL WINDOW -->
    <div id="tutorial" class="ui-control absolute bottom-4 left-4 z-20">
      <div
        id="tutorial-header"
        class="flex justify-between items-center bg-gray-700 text-white px-3 py-2 rounded-t shadow cursor-pointer"
      >
        <div class="font-bold text-lg">INFO</div>
        <button id="tutorial-toggle" class="text-xl leading-none">−</button>
      </div>

      <div
        id="tutorial-body"
        class="bg-gray-700 text-white rounded-b shadow overflow-auto"
      >
        <!-- Minimized content -->
        <div id="tutorial-content-min" class="p-3">
          <p class="text-sm leading-snug">
            • Drag to select a group of squares and perform matrix
            operations.<br />
            • Selected squares can: drag, group, copy, lock, delete + matrix
            ops<br />
            • Control zoom with slider bar or mouse wheel.
          </p>
        </div>

        <!-- Expanded placeholder content -->
        <div
          id="tutorial-content-full"
          class="p-4 space-y-1 bg-gray-700 text-white rounded-b shadow overflow-auto"
        >
          <!-- <div class="text-lg font-bold mb-2">Full Tutorial</div> -->

          <!-- DRAGGING SECTION -->
          <div>
            <h3 class="text-xl underline mb-1 underline-offset-[6px]">
              Dragging/Selection
            </h3>
            <p class="ml-4 py-1 text-sm leading-snug">
              - Select squares by dragging a rectangle around them, then move
              them by clicking &amp; dragging. You can drag individual squares
              or groups of squares. <br />
              - The number at the top of selected block(s) is the number of
              blocks in that specific group. <br />
              - Once blocks are selected you can use the buttons at the top to
              perform operations on the groups of blocks.
            </p>
          </div>

          <!-- GROUPING SECTION -->
          <div>
            <h3 class="text-xl underline mb-1 underline-offset-[6px]">
              Grouping
            </h3>
            <p class="ml-4 py-1 text-sm leading-snug">
              - When blocks are selected you can click the "Group" button to
              arrange blocks into a square grid formation. Locked blocks will
              not be affected.
            </p>
          </div>

          <!-- LOCKING SECTION -->
          <div>
            <h3 class="text-xl underline mb-1 underline-offset-[6px]">
              Locking
            </h3>
            <p class="ml-4 py-1 text-sm leading-snug">
              - After selecting a group, hit “Lock” so that group moves as one
              unit. It will stay continuously selected and you won't be able to
              break up the formation. <br />
              - The locking functionality is very robust. The blocks are
              selected but unlocked selected blocks and locked selected blocks
              will not interact with each other. They can not be grouped.
            </p>
          </div>

          <!-- ZOOMING SECTION -->
          <div>
            <h3 class="text-xl underline mb-1 underline-offset-[6px]">
              Zooming
            </h3>
            <p class="ml-4 py-1 text-sm leading-snug">
              - Use the slider bar or mouse wheel to zoom in and out on the
              canvas. (or +/- buttons)
            </p>
          </div>

          <!-- ADD COPY DELETE SECTION -->
          <div>
            <h3 class="text-xl underline mb-1 underline-offset-[6px]">
              Add, Copy, Delete
            </h3>
            <p class="ml-4 py-1 text-sm leading-snug">
              - Add Square will spawn a new square under the current selection
              (or top right). <br />
              - Copy button will copy the current selection and paste the copy
              on top of the old selection. Copying one row of blocks will paste
              the new row directly under the original. This means you can
              quickly build large square groups using the starting blocks.<br />
              - Delete will remove the current selection
            </p>
          </div>

          <!-- LEGEND SECTION -->
          <div>
            <h3 class="text-xl underline mb-1 underline-offset-[6px]">
              Legend
            </h3>
            <p class="ml-4 py-1 text-sm leading-snug">
              - The legend allows you to change how much a block represents. By
              default a single block represents 1 unit (number is hidden). This
              can be changed by clicking the arrow buttons or entering your own
              number. Remove the text to go back to blank squares.
            </p>
          </div>
        </div>
      </div>
    </div>

    <!-- outer panel -->
    <div
      id="panel"
      class="flex flex-col w-full h-[calc(100vh-16px)] max-w-[calc(100vw-16px)] bg-gray-800 rounded-lg border-2 border-gray-700 overflow-visible"
    >
      <!-- panel header -->
      <div class="flex items-center justify-center space-x-4 py-2">
        <div
          class="ml-3 text-3xl text-white font-bold underline underline-offset-[6px]"
        >
          Matrix Tool
        </div>
        <div id="kofi-widget">
          <script src="https://storage.ko-fi.com/cdn/widget/Widget_2.js"></script>
          <script>
            kofiwidget2.init("Support me on Ko-fi", "#72a4f2", "J3J51GNZVY");
            kofiwidget2.draw();
          </script>
        </div>
      </div>

      <!-- zooms here -->
      <div id="container" class="relative flex-1 overflow-visible">
        <!-- boxes injected here -->
      </div>
    </div>

    <div class="landing-overlay" id="landingOverlay">
      <div class="landing-content">
        <h1>Welcome To Matrix Tool</h1>
        <p>
          The matrix functionality is similar to the scale tool, except squares
          can now represent individual numbers. Matrix operations can be
          visualized smoothly with easy to follow animations.
        </p>
        <div class="landing-buttons">
          <button class="landing-button primary" id="continueBtn">
            Continue
          </button>
          <button class="landing-button" id="scaleToolBtn">Scale Tool</button>
        </div>
      </div>
    </div>

    <div
      id="floating-tutorial"
      class="fixed z-50 inline-flex flex-col items-start bg-gray-600 bg-opacity-90 text-white px-2 py-1 rounded-lg shadow-lg border border-gray-400"
      style="
        top: 7.5rem;
        left: 1.5rem;
        min-width: 0;
        max-width: 15rem;
        display: none;
      "
    >
      <div id="floating-tutorial-text" class="text-sm leading-snug break-words">
        <!-- Tutorial text goes here -->
      </div>
      <button
        id="floating-tutorial-next"
        class="absolute bg-gray-400 text-gray-900 px-2 py-1 rounded shadow hover:bg-gray-300 text-xs font-semibold"
        style="
          right: -0.2rem;
          bottom: -0.2rem;
          transition: background 0.2s;
          transform: translate(50%, 50%);
        "
      >
        Next
      </button>
    </div>

    <!--********************** JAVASCRIPT*****************************************************-->
    <script>
      // Catch all uncaught errors:
      window.onerror = function (message, source, lineno, colno, error) {
        alert(
          `JavaScript error:\n` +
            `Message: ${message}\n` +
            `Source: ${source}\n` +
            `Line: ${lineno}, Column: ${colno}`
        );
        // return false to let the error also go to the console if devtools is open
        return false;
      };

      document.addEventListener("DOMContentLoaded", () => {
        // Landing overlay logic
        const landingOverlay = document.getElementById("landingOverlay");
        const continueBtn = document.getElementById("continueBtn");
        const scaleToolBtn = document.getElementById("scaleToolBtn");
        let onLandingPage = true;

        document.getElementById("reset-btn").addEventListener("click", () => {
          localStorage.setItem("isReset", "true");
          window.location.reload();
          /* // remove all selected boxes
          container.querySelectorAll(".box").forEach((el) => el.remove());

          container
            .querySelectorAll(".sel-count-label")
            .forEach((lbl) => lbl.remove());

          lockedBoxes.clear();
          // clear any selection state and count-label
          COUNT = squareLength * squareLength;
          clearSelection(); */
        });

        // Check if we've shown the landing page before
        let isReset = localStorage.getItem("isReset") === "true";

        // If we want to always show it (or haven't seen it yet)
        if (!isReset) {
          landingOverlay.classList.remove("hidden");
        } else {
          landingOverlay.classList.add("hidden");
          onLandingPage = false;
        }

        localStorage.setItem("isReset", "false");

        // Scale tool button - hide overlay and save preference
        continueBtn.addEventListener("click", function () {
          landingOverlay.classList.add("hidden");

          onLandingPage = false;
        });

        // Matrix tool button (placeholder for now)
        scaleToolBtn.addEventListener("click", function () {
          window.location.href = "/scale_tool/";
        });

        // Floating tutorial logic
        const floatingTutorial = document.getElementById("floating-tutorial");
        const floatingTutorialText = document.getElementById(
          "floating-tutorial-text"
        );
        const floatingTutorialNext = document.getElementById(
          "floating-tutorial-next"
        );

        const tutorialSteps = [
          {
            text: "Click a number to change its value. Switch squares using arrow keys.",
            x: 346,
            y: 71,
          },
          {
            text: "Click and drag to create a selection rectangle around the matrix.",
            x: 274,
            y: 103,
          },
          {
            text: "Click the Transpose button to transpose rows and columns.",
            x: 970,
            y: 83,
          },
          {
            text: "Click copy to copy selected matrix",
            x: 140,
            y: 71,
          },
          {
            text: "Drag the new matrix to the right",
            x: 587,
            y: 99,
          },
          {
            text: "Make a new selection to capture both matrices",
            x: 328,
            y: 91,
          },
          {
            text: "Click addition button to perform matrix addition",
            x: 955,
            y: 75,
          },
          {
            text: "Make another copy and select all the squares",
            x: 638,
            y: 109,
          },
          {
            text: "Click Group to group all selected squares into 1 matrix",
            x: 955,
            y: 75,
          },
          {
            text: "Zoom with mousewheel or slider bar",
            x: 950,
            y: 242,
          },
        ];

        let tutorialStep = 0;

        function showTutorialStep(step) {
          const s = tutorialSteps[step];
          floatingTutorialText.textContent = s.text;
          floatingTutorial.style.display = "flex";
          if (typeof s.x === "number" && typeof s.y === "number") {
            floatingTutorial.style.left = s.x + "px";
            floatingTutorial.style.top = s.y + "px";
          }
        }

        floatingTutorialNext.addEventListener("click", () => {
          tutorialStep++;
          if (tutorialStep < tutorialSteps.length) {
            showTutorialStep(tutorialStep);
          } else {
            floatingTutorial.style.display = "none";
          }
        });

        //showTutorialStep(tutorialStep);

        // how close to the edge (in px) before we show UI:
        const SHOW_MARGIN = 100;
        const HIDE_MARGIN = 190;
        const editCheckBox = document.getElementById("edit-labels");
        editCheckBox.checked = true;

        const cb = document.getElementById("edit-labels");
        const label = document.getElementById("edit-labels-label");

        label.classList.toggle("flash");
        cb.addEventListener("change", () => {
          // if checked, add the flash class to the label; otherwise remove it
          label.classList.toggle("flash", cb.checked);
        });

        // grab all your controls:
        const uiControls = document.querySelectorAll(".ui-control");
        uiControls.forEach((el) => el.classList.add("visible"));

        function updateUI(e) {
          if (isSelecting || isDragging || onLandingPage) return;
          const x = e.clientX,
            y = e.clientY;
          const w = window.innerWidth,
            h = window.innerHeight;

          // detect if UI is already visible (all controls share .visible)
          const uiVisible = uiControls[0].classList.contains("visible");

          // pick the appropriate margin
          const MARGIN = uiVisible ? HIDE_MARGIN : SHOW_MARGIN;

          // if pointer is within MARGIN of ANY edge:
          const nearEdge =
            x < MARGIN || x > w - MARGIN || y < MARGIN || y > h - MARGIN;

          uiControls.forEach((el) => {
            if (editCheckBox.checked) {
              el.classList.add("visible");
            } else {
              el.classList.toggle("visible", nearEdge);
            }
          });
        }

        // listen once on the whole document:
        document.addEventListener("mousemove", updateUI);

        // also trigger on touch (optional):
        //document.addEventListener("touchstart", updateUI);

        // keep track of clusters the user has “locked” by clicking their badge
        const lockedBoxes = new Set();

        const panel = document.getElementById("panel");
        const container = document.getElementById("container");
        const squareLength = 3;
        let COUNT = squareLength * squareLength;
        const SIZE = 96; // px
        const GAP = 16; // px WIP
        let zoomLevel = 0.6;

        let history = [];
        let isRestoring = false;

        function getMatrixState() {
          return Array.from(container.querySelectorAll(".box")).map((box) => ({
            x: +box.dataset.x,
            y: +box.dataset.y,
            value: box.querySelector(".box-input").value,
            selected: box.classList.contains("selected"),
            locked: box.classList.contains("locked"),
          }));
        }

        function setMatrixState(state) {
          isRestoring = true;
          // Remove all boxes
          container.querySelectorAll(".box").forEach((box) => box.remove());
          // Rebuild boxes
          state.forEach((data) => {
            createBox(data.x, data.y, data.value);
            const box = container.lastChild;
            if (data.selected) box.classList.add("selected");
            if (data.locked) box.classList.add("locked");
          });
          isRestoring = false;
          renderClusterLabels();
        }

        // Call this after every user action that changes the matrix
        function saveHistory() {
          if (isRestoring) return;
          history.push(JSON.parse(JSON.stringify(getMatrixState())));
          // Optionally limit history size
          if (history.length > 100) history.shift();
        }

        // Undo handler
        const undobtn = document.getElementById("undo-btn");
        undobtn.addEventListener("click", () => {
          //e.preventDefault();
          if (history.length <= 1) return; // Prevent undoing past the first state
          //history.pop(); // Remove current state
          setMatrixState(history[history.length - 1]);
        });

        function repositionCountLabel() {
          const lbl = container.querySelector(".sel-count-label");
          if (!lbl) return;

          const selectedEls = Array.from(
            container.querySelectorAll(".box.selected")
          );
          if (!selectedEls.length) {
            lbl.remove();
            return;
          }

          const xs = selectedEls.map((el) => +el.dataset.x);
          const ys = selectedEls.map((el) => +el.dataset.y);
          const minX = Math.min(...xs);
          const maxX = Math.max(...xs) + SIZE;
          const minY = Math.min(...ys);

          const labelX = minX + (maxX - minX) / 2;
          const labelY = minY - 50;

          lbl.style.left = `${labelX}px`;
          lbl.style.top = `${labelY}px`;
          lbl.style.transform = `translateX(-50%) scale(${1 / zoomLevel})`;
        }

        //let numArray = [1, 2, 3, 4, 5, 6, 7, 8, 9];
        // 1) create boxes (blank)
        function defaultMatrix(xOffset = 0) {
          for (let i = 0; i < COUNT; i++) {
            const box = document.createElement("div");
            box.className = [
              "box",
              "absolute",
              "w-24",
              "h-24",
              "bg-gray-700",
              "rounded-lg",
              "shadow-lg",
              "cursor-move",
            ].join(" "); // 'floating'
            const cols = Math.sqrt(COUNT); // number of columns you want in your grid
            const startX = xOffset + 650 + (i % cols) * (SIZE + GAP);
            const startY = 250 + Math.floor(i / cols) * (SIZE + GAP);
            box.style.left = startX + "px";
            box.style.top = startY + "px";
            box.dataset.x = startX;
            box.dataset.y = startY;

            /* const label = document.createElement("div");
          label.className = "box-label";
          label.textContent = document.getElementById("block-value").value;
          box.appendChild(label); */
            const input = document.createElement("input");
            input.type = "text"; // or "number" if you prefer
            input.value = i + 1; //document.getElementById("block-value").value; // initialize it
            input.className = "box-input";
            input.addEventListener("change", saveHistory); //SAVE MATRIX HISTORY FOR UNDO*****************

            box.appendChild(input);
            box.classList.add("selected");
            // random float phase
            //box.style.animationDelay = `-${Math.random()*3}s`;
            container.appendChild(box);
          }
        }
        defaultMatrix();
        defaultMatrix(4 * (SIZE + GAP));
        saveHistory(); //SAVE MATRIX HISTORY FOR UNDO*****************

        // helper: create a new box at (x,y) and hook up dragging
        let indx = COUNT;
        function createBox(x, y, value) {
          const box = document.createElement("div");
          box.className = [
            "box",
            "absolute",
            "w-24",
            "h-24",
            "bg-gray-700",
            "rounded-lg",
            "shadow-lg",
            "cursor-move",
          ].join(" ");
          box.style.left = x + "px";
          box.style.top = y + "px";
          box.dataset.x = x;
          box.dataset.y = y;
          box.style.animationDelay = `-${Math.random() * 3}s`;

          const input = document.createElement("input");
          input.type = "text"; // or "number" if you prefer
          input.className = "box-input";
          input.addEventListener("change", saveHistory); //SAVE MATRIX HISTORY FOR UNDO*****************

          if (!document.getElementById("edit-labels").checked) {
            input.classList.add("disabled");
          }
          box.appendChild(input);

          container.appendChild(box);
          box.classList.add("selected");
          if (value) {
            input.value = value;
          } else {
            indx += 1;
            input.value = indx;
          }
          //if (isCopy) box.classList.add(".inSelection");
          //interact(box).draggable(dragConfig);
        }

        // 2) selection‐rectangle (scaled!)
        let isSelecting = false,
          selDiv = null,
          selStart = { x: 0, y: 0 };

        function clearSelection() {
          // only un-select boxes that aren't locked
          container.querySelectorAll(".box.selected").forEach((el) => {
            if (!lockedBoxes.has(el)) {
              el.classList.remove("selected");

              // remove any old count‐labels
              container
                .querySelectorAll(".sel-count-label")
                .forEach((el) => el.remove());
            }
          });
          // 1) clear any prior inSelection flags
          container
            .querySelectorAll(".box.inSelection")
            .forEach((el) => el.classList.remove("inSelection"));
        }

        function clusterBoxes(boxes, proximity = SIZE + 20) {
          const n = boxes.length;
          if (n === 0) return [];
          const parent = [...Array(n).keys()];
          function find(i) {
            return parent[i] === i ? i : (parent[i] = find(parent[i]));
          }
          function union(a, b) {
            parent[find(b)] = find(a);
          }
          for (let i = 0; i < n; i++) {
            const xi = +boxes[i].dataset.x,
              yi = +boxes[i].dataset.y;
            for (let j = i + 1; j < n; j++) {
              const xj = +boxes[j].dataset.x,
                yj = +boxes[j].dataset.y;
              if (
                Math.abs(xi - xj) <= proximity &&
                Math.abs(yi - yj) <= proximity
              ) {
                union(i, j);
              }
            }
          }
          const groups = {};
          for (let i = 0; i < n; i++) {
            const r = find(i);
            (groups[r] ||= []).push(boxes[i]);
          }
          return Object.values(groups);
        }

        function renderClusterLabels() {
          // 1) clear old labels
          container
            .querySelectorAll(".sel-count-label")
            .forEach((lbl) => lbl.remove());

          // 2) grab current selected boxes
          const els = Array.from(container.querySelectorAll(".box.selected"));
          if (!els.length) return;

          const matrices = clusterBoxes(els);

          // 5) for each group, append a label
          matrices.forEach((cluster) => {
            // compute bounding‐box of this cluster
            const xs = cluster.map((el) => +el.dataset.x),
              ys = cluster.map((el) => +el.dataset.y);
            const minX = Math.min(...xs),
              maxX = Math.max(...xs) + SIZE,
              minY = Math.min(...ys);

            const lbl = document.createElement("div");
            lbl.className = [
              "sel-count-label",
              "bg-gray-700",
              "text-white",
              "px-2",
              "py-1",
              "rounded",
              "shadow",
              "pointer-events-none",
              "z-20",
            ].join(" ");

            // get the user’s “blocks → value” multiplier:
            /* let perBlock = parseFloat(
              document.getElementById("block-value").value
            );
            if (isNaN(perBlock) || perBlock < 1) {
              perBlock = 1; // enforce minimum
            } */
            lbl.textContent = cluster.length * 1;

            // position & cancel zoom
            const labelX = minX + (maxX - minX) / 2;
            const labelY = minY - 50;
            lbl.style.left = `${labelX}px`;
            lbl.style.top = `${labelY}px`;
            lbl.style.transformOrigin = "center bottom";
            lbl.style.transform = `translateX(-50%) scale(${1 / zoomLevel})`;

            container.appendChild(lbl);
          });
        }

        function createFloatingOperationSymbol(
          x,
          y,
          isAddition = true,
          floatDown = true
        ) {
          const symbol = document.createElement("div");
          symbol.style.position = "absolute";
          const halfWidth = 32 / 2; // px, matches w-8
          symbol.style.left = x - halfWidth + "px";
          symbol.style.top = y + "px";
          if (!floatDown) symbol.style.top = y - halfWidth + "px";
          symbol.style.pointerEvents = "none";
          symbol.style.zIndex = "50";
          symbol.style.color = "white";
          symbol.style.fontSize = "2rem";
          symbol.style.opacity = "1";
          symbol.style.transition =
            "transform 1s ease-out, opacity 1s ease-out";

          if (isAddition) {
            symbol.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-8 h-8">
      <path stroke-linecap="round" stroke-linejoin="round" d="M12 4.5v15m7.5-7.5h-15" />
    </svg>`;
          } else {
            symbol.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-8 h-8">
      <path stroke-linecap="round" stroke-linejoin="round" d="M6 18 18 6M6 6l12 12" />
    </svg>`;
          }

          container.appendChild(symbol);

          // Force reflow then start animation
          symbol.offsetWidth;

          // Animate floating up and fading out
          if (floatDown) {
            //float down
            symbol.style.transform = "translateY(50px) scale(1.5)";
          } else {
            //float up
            symbol.style.transform = "translateY(-50px) scale(1.5)";
          }

          symbol.style.opacity = "0";

          // Remove after animation completes
          setTimeout(() => {
            if (symbol.parentNode) {
              symbol.remove();
            }
          }, 1000);
        }

        container.addEventListener("mousedown", (e) => {
          if (e.button !== 0 || e.target !== container) return;

          // immediately hide all your UI-controls on drag start:
          uiControls.forEach((el) => el.classList.remove("visible"));

          isSelecting = true;
          console.log("iselecting:", isSelecting);
          const crect = container.getBoundingClientRect();

          // ↓ Adjust start to container‐local, unscaled coords
          selStart.x = (e.clientX - crect.left) / zoomLevel;
          selStart.y = (e.clientY - crect.top) / zoomLevel;

          selDiv = document.createElement("div");
          selDiv.className = "select-rect";
          selDiv.style.left = selStart.x + "px";
          selDiv.style.top = selStart.y + "px";
          selDiv.style.width = "0px";
          selDiv.style.height = "0px";
          container.appendChild(selDiv);

          clearSelection();
          window.addEventListener("mousemove", updateSelectRect);
          window.addEventListener("mouseup", finishSelectRect);
        });

        function updateSelectRect(e) {
          if (!isSelecting) return;
          const crect = container.getBoundingClientRect();

          // ↓ Compute current point in container coords, dividing out zoom
          const curX = (e.clientX - crect.left) / zoomLevel;
          const curY = (e.clientY - crect.top) / zoomLevel;

          const x1 = Math.min(selStart.x, curX),
            y1 = Math.min(selStart.y, curY),
            x2 = Math.max(selStart.x, curX),
            y2 = Math.max(selStart.y, curY);

          selDiv.style.left = x1 + "px";
          selDiv.style.top = y1 + "px";
          selDiv.style.width = x2 - x1 + "px";
          selDiv.style.height = y2 - y1 + "px";
        }

        function finishSelectRect(e) {
          if (!isSelecting) return;
          isSelecting = false;
          window.removeEventListener("mousemove", updateSelectRect);
          window.removeEventListener("mouseup", finishSelectRect);

          // get the selection‐rectangle bounds
          const rectX = parseFloat(selDiv.style.left),
            rectY = parseFloat(selDiv.style.top),
            rectW = parseFloat(selDiv.style.width),
            rectH = parseFloat(selDiv.style.height);

          const selB = selDiv.getBoundingClientRect();
          selDiv.remove();
          selDiv = null;

          // 1) clear any prior inSelection flags
          container
            .querySelectorAll(".box.inSelection")
            .forEach((el) => el.classList.remove("inSelection"));

          container.querySelectorAll(".box").forEach((el) => {
            const r = el.getBoundingClientRect();
            if (
              r.left < selB.right &&
              r.right > selB.left &&
              r.top < selB.bottom &&
              r.bottom > selB.top
            ) {
              el.classList.add("selected", "inSelection");
            }
          });
          lockArray = Array.from(
            container.querySelectorAll(".box.locked.inSelection")
          );
          console.log("length:", lockArray.length, " size:", lockedBoxes.size);

          if (lockArray.length != lockedBoxes.size) {
            lockArray.forEach((el) => {
              el.classList.remove("inSelection"),
                el.classList.add("removeSelection");
            });
          }

          // 2) compute bounding‐box of selected boxes in container coords
          const selectedEls = Array.from(
            container.querySelectorAll(".box.selected:not(.removeSelection)")
          );
          if (selectedEls.length) {
            renderClusterLabels();
          }
        }

        // 3) draggable + group‐drag (unchanged)
        let isDragging = false,
          selectedEls = [],
          initPos = [],
          delta = { x: 0, y: 0 };
        interact(".box").draggable({
          inertia: true,
          modifiers: [
            interact.modifiers.restrictRect({
              restriction: panel,
              endOnly: false,
              elementRect: { top: 0, left: 0, bottom: 1, right: 1 },
            }),
          ],
          onstart(event) {
            // immediately hide all your UI-controls on drag start:
            uiControls.forEach((el) => el.classList.remove("visible"));
            isDragging = true;
            const t = event.target;

            let one = false;
            let lockDrag = false;
            let lockDragAll = false;
            let lockedBoxClicked = false;
            if (
              !t.classList.contains("selected") &&
              !t.classList.contains("locked")
            ) {
              clearSelection();
              t.classList.add("selected");
              one = true;
            }

            if (t.classList.contains("locked")) {
              //clearSelection();
              //t.classList.add('selected');
              lockedBoxClicked = true;
            }

            // 1) Grab only the boxes you just rectangle-selected:
            //    (we’re assuming finishSelectRect painted them with .inSelection)
            let rectSel = Array.from(
              container.querySelectorAll(".box.inSelection")
            );

            console.log("rectSel length:", rectSel.length);
            //let noSelect = false;
            if (rectSel.length == 0) {
              rectSel = Array.from(container.querySelectorAll(".box.selected"));
              if (lockedBoxClicked) {
                clearSelection();
                //t.classList.add('selected');
                lockDrag = true;
              }
            }

            // 2) Split that into locked vs unlocked:
            const locked = rectSel.filter((el) => lockedBoxes.has(el));
            const unlocked = rectSel.filter((el) => !lockedBoxes.has(el));

            // 3) Decide which group to actually drag:
            let toDrag;
            console.log("unlock length:", unlocked.length);
            console.log("one:", one);
            /* if (noSelect && (unlocked.length == 1)) {
                        toDrag = unlocked;
                        console.log('active');
                    } */
            if (unlocked.length === rectSel.length && lockedBoxClicked) {
              console.log("unlocked active but drag changed to locked");
              clearSelection();
              //t.classList.add('selected');
              toDrag = Array.from(container.querySelectorAll(".box.locked"));
            } else if (one) {
              toDrag = unlocked;
              console.log("one active");
            } else if (lockDrag) {
              toDrag = locked;
              console.log("lockdrag active");
            } else if (locked.length === rectSel.length) {
              // you dragged *only* locked boxes
              toDrag = locked;
              console.log("locked active");
            } else if (unlocked.length === rectSel.length) {
              // you dragged *only* unlocked (freshly selected) boxes
              console.log("unlocked active");
              toDrag = unlocked;
            } else {
              // mixed → drag everything you hit
              console.log("mixed/all active");
              toDrag = rectSel;
            }

            // 4) Build your initPos from *that* array:
            currentInit = toDrag.map((el) => ({
              el,
              x: parseFloat(el.dataset.x),
              y: parseFloat(el.dataset.y),
            }));
            /* selectedEls = Array.from(container.querySelectorAll('.box.selected'));
                    selectedElsLocked = Array.from(container.querySelectorAll('.box.locked')); //could also use: const allLocked = Array.from(lockedBoxes);
                    selectedElsNotLocked = Array.from(container.querySelectorAll('.box.selected:not(.locked)'));

                    const lockedCount = selectedEls.filter(el => lockedBoxes.has(el)).length;
                    const totalCount = selectedEls.length;

                    initPos = selectedEls.map(el => ({
                        el, x: parseFloat(el.dataset.x), y: parseFloat(el.dataset.y)
                    }));
                    initPosLocked = selectedElsLocked.map(el => ({
                        el, x: parseFloat(el.dataset.x), y: parseFloat(el.dataset.y)
                    }));
                    initPosNotLocked = selectedElsNotLocked.map(el => ({
                        el, x: parseFloat(el.dataset.x), y: parseFloat(el.dataset.y)
                    }));

                    const allLocked = (lockedCount === totalCount);
                    const allUnlocked = (lockedCount === 0);
                    const mixed = !allLocked && !allUnlocked;

                    // now you can branch on the three states:
                    if (allLocked) {
                        // only locked boxes were selected
                        currentInit = initPosLocked;
                    }
                    else if (allUnlocked) {
                        // only freshly‐selected (unlocked) boxes
                        currentInit = initPosNotLocked;
                    }
                    else { //mixed
                        // both kinds in the same drag‐select
                        currentInit = initPos;
                    } */

            delta = { x: 0, y: 0 };
            groupDrag = selectedEls.length > 1;
            console.log("");
            //groupDrag = true;
          },
          onmove(event) {
            const dx = event.dx / zoomLevel,
              dy = event.dy / zoomLevel;
            delta.x += dx;
            delta.y += dy;

            currentInit.forEach((item) => {
              const nx = item.x + delta.x,
                ny = item.y + delta.y;
              item.el.style.left = nx + "px";
              item.el.style.top = ny + "px";
              item.el.dataset.x = nx;
              item.el.dataset.y = ny;
            });

            renderClusterLabels();
          },
          onend(event) {
            // drag just finished
            isDragging = false;
            saveHistory(); //SAVE MATRIX HISTORY FOR UNDO*****************
          },
        });

        // 4) zoom logic (updated)
        const { width: origW, height: origH } =
          container.getBoundingClientRect();

        function applyZoom() {
          // scale the visuals
          container.style.flex = "none";
          container.style.transform = `scale(${zoomLevel})`;
          // grow/shrink the raw box so its hit‐area stays constant
          container.style.width = `${origW / zoomLevel}px`;
          container.style.height = `${origH / zoomLevel}px`;

          // 2) update every count‐label so it stays constant in screen-space
          container.querySelectorAll(".sel-count-label").forEach((lbl) => {
            // we already set transformOrigin to 'center bottom' when we created it
            lbl.style.transform = `translateX(-50%) scale(${1 / zoomLevel})`;
          });
        }

        /* document.getElementById("zoom-in").onclick = () => {
          zoomLevel = Math.min(2, zoomLevel + 0.1);
          applyZoom();
        };
        document.getElementById("zoom-out").onclick = () => {
          zoomLevel = Math.max(0.3, zoomLevel - 0.1);
          applyZoom();
        }; */

        // initialize on load
        applyZoom();

        // grab the new button
        const groupBtn = document.getElementById("group-btn");

        groupBtn.addEventListener("click", () => {
          // find all selected boxes
          const selected = Array.from(
            container.querySelectorAll(".box.selected:not(.locked)")
          );
          const n = selected.length;
          if (n === 0) return;

          // sort in‐place by that inner input’s value:
          selected.sort((a, b) => {
            const aVal =
              parseFloat(a.querySelector("input.box-input").value) || 0;
            const bVal =
              parseFloat(b.querySelector("input.box-input").value) || 0;
            return aVal - bVal;
          });

          // 1) add the transition class
          selected.forEach((el) => el.classList.add("group-transition"));

          // 2) force the browser to notice the class before we move them
          //    so the transition actually runs:
          selected[0].offsetWidth; // reflow

          // 1) compute grid dimensions
          const cols = Math.ceil(Math.sqrt(n)); // e.g. sqrt(7)=2.64→3 columns
          const rows = Math.ceil(n / cols); // fill rows of that many cols
          const GAP = 16; // same gap you used when laying out
          const SIZE = 96; // your box size

          // 2) compute the “center” of the current selection
          const sum = selected.reduce(
            (s, el) => ({
              x: s.x + parseFloat(el.dataset.x),
              y: s.y + parseFloat(el.dataset.y),
            }),
            { x: 0, y: 0 }
          );

          const centerX = sum.x / n;
          const centerY = sum.y / n;

          // 3) figure out total pixel dimensions of the new grid
          const totalW = (cols - 1) * (SIZE + GAP);
          const totalH = (rows - 1) * (SIZE + GAP);

          // 4) pick a start-point so that the grid’s center sits at (centerX, centerY)
          const startX = centerX - totalW / 2;
          const startY = centerY - totalH / 2;

          // 5) re-position each box into its [row, col] slot
          selected.forEach((el, i) => {
            const row = Math.floor(i / cols);
            const col = i % cols;
            const x = startX + col * (SIZE + GAP);
            const y = startY + row * (SIZE + GAP);

            el.style.left = x + "px";
            el.style.top = y + "px";
            el.dataset.x = x;
            el.dataset.y = y;
          });

          // 4) after the animation duration, strip the class so future drags are instant
          setTimeout(() => {
            selected.forEach((el) => el.classList.remove("group-transition"));
          }, 300); // match the 0.3s in your CSS

          // Remove any existing count‐labels
          //container.querySelectorAll('.sel-count-label')
          //        .forEach(lbl => lbl.remove());

          //clearSelection();
          renderClusterLabels();
          saveHistory(); //SAVE MATRIX HISTORY FOR UNDO*****************
        });

        // 6) **ADD SQUARE** button
        document.getElementById("add-square").addEventListener("click", () => {
          const selected = Array.from(
            container.querySelectorAll(".box.selected")
          );
          let x, y;

          if (selected.length > 0) {
            // find the SW-most selected box
            const sw = selected.reduce((best, el) => {
              const ex = parseFloat(el.dataset.x),
                ey = parseFloat(el.dataset.y);
              const bx = parseFloat(best.dataset.x),
                by = parseFloat(best.dataset.y);
              // pick the one with larger y (lower on screen),
              // and if tie, the smaller x (more to the left)
              if (ey > by || (ey === by && ex < bx)) return el;
              return best;
            }, selected[0]);

            x = parseFloat(sw.dataset.x);
            y = parseFloat(sw.dataset.y) + SIZE + GAP; // directly below
          } else {
            // fallback: top-left if nothing selected
            x = 16;
            y = 80;
          }

          createBox(x, y);
          saveHistory(); //SAVE MATRIX HISTORY FOR UNDO*****************
        });

        const slider = document.getElementById("zoom-slider");

        // whenever the slider moves, set zoomLevel and redraw
        slider.addEventListener("input", (e) => {
          zoomLevel = parseFloat(e.target.value);
          applyZoom();
        });

        // keep the slider in sync when + / – buttons are clicked:
        function updateSlider() {
          slider.value = zoomLevel.toFixed(2);
        }

        document.getElementById("copy-btn").addEventListener("click", () => {
          const selected = Array.from(
            container.querySelectorAll(".box.selected")
          );
          if (selected.length === 0) return;

          // find SW-most selected box
          const sw = selected.reduce((best, el) => {
            const ex = +el.dataset.x,
              ey = +el.dataset.y;
            const bx = +best.dataset.x,
              by = +best.dataset.y;
            return ey > by || (ey === by && ex < bx) ? el : best;
          }, selected[0]);

          const swX = +sw.dataset.x,
            swY = +sw.dataset.y;

          // compute each box’s offset from SW and get the input value
          const deltas = selected.map((el) => {
            const input = el.querySelector("input.box-input");
            return {
              dx: +el.dataset.x - swX,
              dy: +el.dataset.y - swY,
              val: input.value,
            };
          });

          // new group’s origin — directly below SW
          const baseX = swX,
            baseY = swY + SIZE / 2 + GAP;

          // clear old selection, then paste copies
          clearSelection();
          container
            .querySelectorAll(".sel-count-label")
            .forEach((lbl) => lbl.remove());
          //repositionCountLabel();

          deltas.forEach((delta) => {
            //console.log(delta.val);
            createBox(baseX + delta.dx, baseY + delta.dy, delta.val);
          });
          saveHistory(); //SAVE MATRIX HISTORY FOR UNDO*****************
        });

        document.getElementById("delete-btn").addEventListener("click", () => {
          // remove all selected boxes
          container
            .querySelectorAll(".box.selected")
            .forEach((el) => el.remove());
          // clear any selection state and count-label
          clearSelection();
          saveHistory(); //SAVE MATRIX HISTORY FOR UNDO*****************
        });

        document.getElementById("lock-btn").addEventListener("click", () => {
          const selected = Array.from(
            container.querySelectorAll(".box.selected")
          );
          selected.forEach((box) => {
            if (lockedBoxes.has(box)) {
              // it’s already locked → unlock it
              lockedBoxes.delete(box);
              box.classList.remove("locked");
            } else {
              // not locked yet → lock it
              lockedBoxes.add(box);
              box.classList.add("locked");
            }
          });
          clearSelection();
          //console.log('Locked boxes count:', lockedBoxes.size);
        });

        // --- cookie helpers ---
        function setCookie(name, val, days) {
          const d = new Date();
          //d.setTime(d.getTime() + days * 1000);
          d.setTime(d.getTime() + (days || 365) * 24 * 60 * 60 * 1000);
          document.cookie =
            name +
            "=" +
            encodeURIComponent(val) +
            ";expires=" +
            d.toUTCString() +
            ";path=/";
        }

        function getCookie(name) {
          return document.cookie.split("; ").reduce((r, c) => {
            const [k, v] = c.split("=");
            return k === name ? decodeURIComponent(v) : r;
          }, "");
        }

        // --- tutorial toggle logic ---
        const tut = document.getElementById("tutorial");
        const toggle = document.getElementById("tutorial-toggle");

        // initialize from cookie
        const seen = getCookie("tutorialSeen");
        if (!seen) {
          // first visit → expanded
          tut.classList.add("expanded");
          toggle.textContent = "−";
        } else {
          // returning → collapsed
          tut.classList.add("collapsed");
          toggle.textContent = "+";
        }

        // when you click the toggle:
        toggle.addEventListener("click", () => {
          if (tut.classList.contains("expanded")) {
            // collapse it
            tut.classList.remove("expanded");
            tut.classList.add("collapsed");
            toggle.textContent = "+";
            setCookie("tutorialSeen", "true", 1); //1 day
          } else {
            // expand it
            tut.classList.remove("collapsed");
            tut.classList.add("expanded");
            toggle.textContent = "−";
          }
        });

        /* document.getElementById("block-value").addEventListener("input", () => {
          const boxVals = Array.from(container.querySelectorAll(".box"));
          boxVals.forEach((box) => {
            const label = box.querySelector(".box-label");
            label.textContent = document.getElementById("block-value").value;
          });
           container.querySelectorAll(".box").forEach((el) => {
           // el.box-label = document.getElementById("block-value").value;
          }); 
           const blockInput = document.getElementById("block-value");
          let perBlock = parseFloat(blockInput.value);
          if (!isNaN(perBlock) && perBlock < 1) {
            perBlock = 1; // enforce minimum
          }
          blockInput.value = perBlock;  // update the actual input 
          // re-draw labels for whatever is currently selected
          renderClusterLabels();
        }); */

        // Add this where you have your other slider code
        document.addEventListener(
          "wheel",
          function (e) {
            const updatedTut = document.getElementById("tutorial");
            console.log(updatedTut.classList.contains("visible"));
            if (
              updatedTut.classList.contains("expanded") &&
              updatedTut.matches(".ui-control:hover")
            )
              return;
            // Prevent default scrolling
            e.preventDefault();

            if (e.deltaY < 0) {
              // Scrolling up - zoom in
              zoomLevel = Math.min(1.5, zoomLevel + 0.1);
              applyZoom();
            } else {
              // Scrolling down - zoom out
              zoomLevel = Math.max(0.2, zoomLevel - 0.1);
              applyZoom();
            }
            updateSlider();
          },
          { passive: false }
        );

        // Helper to get all enabled box-inputs as an array
        function getAllBoxInputs() {
          return Array.from(
            document.querySelectorAll(".box-input:not(.disabled)")
          );
        }

        // Enable arrow key navigation between inputs
        function enableArrowNavigation() {
          getAllBoxInputs().forEach((input) => {
            input.addEventListener("keydown", function (e) {
              if (
                !["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(
                  e.key
                )
              )
                return;

              // Get current box position
              const box = input.closest(".box");
              const x = parseFloat(box.dataset.x);
              const y = parseFloat(box.dataset.y);

              // Find the closest input in the arrow direction
              let minDist = Infinity,
                nextInput = null;
              getAllBoxInputs().forEach((otherInput) => {
                if (otherInput === input) return;
                const otherBox = otherInput.closest(".box");
                const ox = parseFloat(otherBox.dataset.x);
                const oy = parseFloat(otherBox.dataset.y);

                // Only consider boxes in the right direction
                let valid = false,
                  dist = Infinity;
                if (
                  e.key === "ArrowUp" &&
                  oy < y &&
                  Math.abs(ox - x) < SIZE / 2
                ) {
                  valid = true;
                  dist = y - oy;
                }
                if (
                  e.key === "ArrowDown" &&
                  oy > y &&
                  Math.abs(ox - x) < SIZE / 2
                ) {
                  valid = true;
                  dist = oy - y;
                }
                if (
                  e.key === "ArrowLeft" &&
                  ox < x &&
                  Math.abs(oy - y) < SIZE / 2
                ) {
                  valid = true;
                  dist = x - ox;
                }
                if (
                  e.key === "ArrowRight" &&
                  ox > x &&
                  Math.abs(oy - y) < SIZE / 2
                ) {
                  valid = true;
                  dist = ox - x;
                }
                if (valid && dist < minDist) {
                  minDist = dist;
                  nextInput = otherInput;
                }
              });

              if (nextInput) {
                e.preventDefault();
                nextInput.focus();
                nextInput.select();
              }
            });
          });
        }

        // Call this after boxes are created and when edit mode changes
        enableArrowNavigation();

        // grab the checkbox and all the box-inputs
        const toggleEdit = document.getElementById("edit-labels"); // your checkbox

        //toggleEdit.dispatchEvent(new Event("change"));
        // when the checkbox changes…
        toggleEdit.addEventListener("change", () => {
          const boxInputs = document.querySelectorAll(".box-input");
          const disable = !toggleEdit.checked; // disable when *not* checked
          boxInputs.forEach((input) => {
            input.classList.toggle("disabled", disable);
          });

          // Re-enable navigation for newly enabled inputs
          if (toggleEdit.checked) {
            enableArrowNavigation();
          }
        });

        document
          .getElementById("tanspose-button")
          .addEventListener("click", () => {
            const selected = Array.from(
              container.querySelectorAll(".box.selected:not(.locked)")
            );
            const n = selected.length;
            if (n === 0) return;

            // 1) add the transition class
            selected.forEach((el) => el.classList.add("transpose-transition"));
            selected[0].offsetWidth; // reflow

            // 2) Find the actual grid structure by detecting rows and columns
            const positions = selected.map((el) => ({
              el,
              x: parseFloat(el.dataset.x),
              y: parseFloat(el.dataset.y),
            }));

            // Group by rows (similar Y coordinates)
            const tolerance = 10;
            const rowGroups = [];

            positions.forEach((pos) => {
              let foundRow = rowGroups.find(
                (row) => Math.abs(row[0].y - pos.y) <= tolerance
              );

              if (foundRow) {
                foundRow.push(pos);
              } else {
                rowGroups.push([pos]);
              }
            });

            // Sort rows by Y position, and within each row by X position
            rowGroups.sort((a, b) => a[0].y - b[0].y);
            rowGroups.forEach((row) => row.sort((a, b) => a.x - b.x));

            // 3) Determine grid dimensions
            const actualRows = rowGroups.length;
            const maxCols = Math.max(...rowGroups.map((row) => row.length));

            // 4) Create a logical grid with ghost positions
            const grid = Array(actualRows)
              .fill()
              .map(() => Array(maxCols).fill(null));

            // Fill the grid with actual elements
            rowGroups.forEach((row, rowIndex) => {
              row.forEach((pos, colIndex) => {
                grid[rowIndex][colIndex] = pos.el;
              });
            });

            // 5) compute the "center" of the current selection
            const sum = selected.reduce(
              (s, el) => ({
                x: s.x + parseFloat(el.dataset.x),
                y: s.y + parseFloat(el.dataset.y),
              }),
              { x: 0, y: 0 }
            );

            const centerX = sum.x / n;
            const centerY = sum.y / n;

            // 6) for transpose: rows become columns, columns become rows
            const newRows = maxCols;
            const newCols = actualRows;

            // 7) figure out total pixel dimensions of the transposed grid
            const GAP = 16;
            const SIZE = 96;
            const totalW = (newCols - 1) * (SIZE + GAP);
            const totalH = (newRows - 1) * (SIZE + GAP);

            // 8) pick a start-point so that the transposed grid's center sits at (centerX, centerY)
            const startX = centerX - totalW / 2;
            const startY = centerY - totalH / 2;

            // 9) NEW: Animate transpose column by column with space-making
            const COLUMN_DELAY = 500; // 500ms delay between each column

            container
              .querySelectorAll(".sel-count-label")
              .forEach((lbl) => lbl.remove());
            for (let col = 0; col < maxCols; col++) {
              setTimeout(() => {
                // FIRST: Move all remaining elements down to make space
                for (
                  let futureCol = col + 1;
                  futureCol < maxCols;
                  futureCol++
                ) {
                  for (let row = 0; row < actualRows; row++) {
                    const element = grid[row][futureCol];
                    if (element) {
                      const currentY = parseFloat(element.dataset.y);
                      const newY = currentY + (SIZE + GAP); // Move down by one row height

                      element.style.top = newY + "px";
                      element.dataset.y = newY;
                    }
                  }
                }

                // SECOND: Move current column elements to their transposed positions
                for (let row = 0; row < actualRows; row++) {
                  const element = grid[row][col];
                  if (element) {
                    // Transpose: element at (row, col) goes to (col, row)
                    const newRow = col;
                    const newCol = row;

                    const x = startX + newCol * (SIZE + GAP);
                    const y = startY + newRow * (SIZE + GAP);

                    element.style.left = x + "px";
                    element.style.top = y + "px";
                    element.dataset.x = x;
                    element.dataset.y = y;
                  }
                }

                // Update cluster labels after each column move
              }, col * COLUMN_DELAY);
            }

            // 10) Remove transition class after all animations complete
            const totalAnimationTime = maxCols * COLUMN_DELAY + 500; // +1000ms for final transition
            setTimeout(() => {
              selected.forEach((el) =>
                el.classList.remove("transpose-transition")
              );
              renderClusterLabels();
            }, totalAnimationTime);
            saveHistory(); //SAVE MATRIX HISTORY FOR UNDO*****************
          });

        document.getElementById("add-btn").addEventListener("click", () => {
          const selected = Array.from(
            container.querySelectorAll(".box.selected:not(.locked)")
          );
          const n = selected.length;
          if (n === 0) return;

          const matrices = clusterBoxes(selected);

          // Need exactly 2 matrices for addition
          if (matrices.length !== 2) {
            alert("Please select exactly 2 matrices for addition");
            return;
          }

          // Sort matrices by leftmost position to determine which is first/second
          matrices.sort((a, b) => {
            const aMinX = Math.min(...a.map((el) => +el.dataset.x));
            const bMinX = Math.min(...b.map((el) => +el.dataset.x));
            return aMinX - bMinX;
          });

          const [matrix1, matrix2] = matrices;

          // Check if matrices have the same dimensions
          if (matrix1.length !== matrix2.length) {
            alert("Matrices must have the same dimensions for addition");
            return;
          }

          // Convert each matrix to a 2D grid structure for proper alignment
          function matrixToGrid(matrix) {
            const tolerance = 10;
            const positions = matrix.map((el) => ({
              el,
              x: parseFloat(el.dataset.x),
              y: parseFloat(el.dataset.y),
            }));

            // Group by rows
            const rowGroups = [];
            positions.forEach((pos) => {
              let foundRow = rowGroups.find(
                (row) => Math.abs(row[0].y - pos.y) <= tolerance
              );
              if (foundRow) {
                foundRow.push(pos);
              } else {
                rowGroups.push([pos]);
              }
            });

            // Sort rows by Y, and within rows by X
            rowGroups.sort((a, b) => a[0].y - b[0].y);
            rowGroups.forEach((row) => row.sort((a, b) => a.x - b.x));

            return rowGroups;
          }

          const grid1 = matrixToGrid(matrix1);
          const grid2 = matrixToGrid(matrix2);

          // Verify same grid structure
          if (
            grid1.length !== grid2.length ||
            grid1.some((row, i) => row.length !== grid2[i].length)
          ) {
            alert("Matrices must have the same dimensions for addition");
            return;
          }

          // Remove count labels during animation
          container
            .querySelectorAll(".sel-count-label")
            .forEach((lbl) => lbl.remove());

          // Create a flat array of pairs for sequential animation
          const pairs = [];
          grid1.forEach((row, rowIndex) => {
            row.forEach((pos, colIndex) => {
              pairs.push({
                left: pos.el,
                right: grid2[rowIndex][colIndex].el,
                leftOriginalX: parseFloat(pos.el.dataset.x),
                leftOriginalY: parseFloat(pos.el.dataset.y),
                rightOriginalX: parseFloat(
                  grid2[rowIndex][colIndex].el.dataset.x
                ),
                rightOriginalY: parseFloat(
                  grid2[rowIndex][colIndex].el.dataset.y
                ),
              });
            });
          });

          let currentPairIndex = 0;
          const ANIMATION_DELAY = 600; // Time between each pair animation

          function animateNextPair() {
            if (currentPairIndex >= pairs.length) {
              // All animations complete, update cluster labels
              renderClusterLabels();
              return;
            }

            const pair = pairs[currentPairIndex];
            const {
              left,
              right,
              leftOriginalX,
              leftOriginalY,
              rightOriginalX,
              rightOriginalY,
            } = pair;

            // Add transition classes
            left.classList.add("group-transition");
            right.classList.add("group-transition");

            // Force reflow
            left.offsetWidth;

            // Step 1: Move both blocks up by SIZE + GAP
            const upwardY = leftOriginalY - (SIZE + GAP);
            left.style.left = leftOriginalX + "px";
            left.style.top = upwardY + "px";
            left.dataset.x = leftOriginalX;
            left.dataset.y = upwardY;

            right.style.left = rightOriginalX + "px";
            right.style.top = upwardY + "px";
            right.dataset.x = rightOriginalX;
            right.dataset.y = upwardY;

            // Step 2: After upward movement, move right block to left block position
            setTimeout(() => {
              right.style.left = leftOriginalX + "px";
              right.style.top = upwardY + "px";
              right.dataset.x = leftOriginalX;
              right.dataset.y = upwardY;

              // Step 3: After horizontal movement, combine values and remove right block
              // (blocks stay at the elevated position)
              setTimeout(() => {
                // Get input values
                const input1 = left.querySelector("input.box-input");
                const input2 = right.querySelector("input.box-input");

                // Parse values (default to 0 if not a number)
                const val1 = parseFloat(input1.value) || 0;
                const val2 = parseFloat(input2.value) || 0;

                // Update left block with the sum
                input1.value = val1 + val2;

                // Show floating addition symbol
                const symbolX = parseFloat(left.dataset.x) + SIZE / 2;
                const symbolY = parseFloat(left.dataset.y) + SIZE;
                createFloatingOperationSymbol(symbolX, symbolY, true, true); // true for addition

                // Remove right block and transition classes
                right.remove();
                left.classList.remove("group-transition");

                // Move to next pair
                currentPairIndex++;
                animateNextPair();
              }, 300); // Wait for horizontal movement
            }, 300); // Wait for upward movement
          }

          // Start the animation sequence
          animateNextPair();
          saveHistory(); //SAVE MATRIX HISTORY FOR UNDO*****************
        });

        document
          .getElementById("multiply-btn")
          .addEventListener("click", () => {
            const selected = Array.from(
              container.querySelectorAll(".box.selected:not(.locked)")
            );
            const n = selected.length;
            if (n === 0) return;

            const matrices = clusterBoxes(selected);

            // Need exactly 2 matrices for multiplication
            if (matrices.length !== 2) {
              alert("Please select exactly 2 matrices for multiplication");
              return;
            }

            // Sort matrices by leftmost position to determine which is first/second
            matrices.sort((a, b) => {
              const aMinX = Math.min(...a.map((el) => +el.dataset.x));
              const bMinX = Math.min(...b.map((el) => +el.dataset.x));
              return aMinX - bMinX;
            });

            const [leftMatrix, rightMatrix] = matrices;

            // Convert each matrix to a 2D grid structure for proper alignment
            function matrixToGrid(matrix) {
              const tolerance = 10;
              const positions = matrix.map((el) => ({
                el,
                x: parseFloat(el.dataset.x),
                y: parseFloat(el.dataset.y),
              }));

              // Group by rows
              const rowGroups = [];
              positions.forEach((pos) => {
                let foundRow = rowGroups.find(
                  (row) => Math.abs(row[0].y - pos.y) <= tolerance
                );
                if (foundRow) {
                  foundRow.push(pos);
                } else {
                  rowGroups.push([pos]);
                }
              });

              // Sort rows by Y, and within rows by X
              rowGroups.sort((a, b) => a[0].y - b[0].y);
              rowGroups.forEach((row) => row.sort((a, b) => a.x - b.x));

              return rowGroups;
            }

            const leftGrid = matrixToGrid(leftMatrix);
            const rightGrid = matrixToGrid(rightMatrix);

            // Verify matrices can be multiplied (left columns = right rows)
            const leftRows = leftGrid.length;
            const leftCols = leftGrid[0]?.length || 0;
            const rightRows = rightGrid.length;
            const rightCols = rightGrid[0]?.length || 0;

            if (leftCols !== rightRows) {
              alert(
                `Cannot multiply matrices: left matrix has ${leftCols} columns but right matrix has ${rightRows} rows`
              );
              return;
            }

            // Remove count labels during animation
            container
              .querySelectorAll(".sel-count-label")
              .forEach((lbl) => lbl.remove());

            // Helper function to create a copy of an element
            function createCopyOfElement(originalEl, x, y) {
              const copy = document.createElement("div");
              copy.className = originalEl.className;
              copy.style.left = x + "px";
              copy.style.top = y + "px";
              copy.dataset.x = x;
              copy.dataset.y = y;

              const originalInput = originalEl.querySelector("input.box-input");
              const copyInput = document.createElement("input");
              copyInput.type = "text";
              copyInput.value = originalInput.value;
              copyInput.className = "box-input";
              copy.appendChild(copyInput);

              container.appendChild(copy);
              return copy;
            }

            // Helper function to reset opacity for a column
            function resetColumnOpacity(colIndex) {
              for (let rowIndex = 0; rowIndex < rightRows; rowIndex++) {
                const element = rightGrid[rowIndex][colIndex].el;
                element.style.opacity = "1";
              }
            }

            // Helper function to reset opacity for a row
            function resetRowOpacity(rowIndex) {
              for (let colIndex = 0; colIndex < leftCols; colIndex++) {
                const element = leftGrid[rowIndex][colIndex].el;
                element.style.opacity = "1";
              }
            }

            // Helper function to lower opacity for a row
            function lowerRowOpacity(rowIndex) {
              for (let colIndex = 0; colIndex < leftCols; colIndex++) {
                const element = leftGrid[rowIndex][colIndex].el;
                element.style.opacity = "0.3";
              }
            }

            function resetLeftRowOpacity(rowIndex) {
              for (let colIndex = 0; colIndex < leftCols; colIndex++) {
                const element = leftGrid[rowIndex][colIndex].el;
                element.style.opacity = "1";
              }
            }

            function moveMatrix(leftMatrix, rightMatrix = [], moveDown = true) {
              let sign = 1;
              if (!moveDown) sign = -1;

              leftMatrix.forEach((el) => {
                el.classList.add("group-transition");
                const currentY = parseFloat(el.dataset.y);
                const newY = currentY + sign * (SIZE + GAP);
                el.style.top = newY + "px";
                el.dataset.y = newY;
              });

              rightMatrix.forEach((el) => {
                el.classList.add("group-transition");
                const currentY = parseFloat(el.dataset.y);
                const newY = currentY + sign * (SIZE + GAP);
                el.style.top = newY + "px";
                el.dataset.y = newY;
              });

              // Remove transition classes after animation
              setTimeout(() => {
                leftMatrix.forEach((el) => {
                  el.classList.remove("group-transition");
                });
                rightMatrix.forEach((el) => {
                  el.classList.remove("group-transition");
                });
              }, 300);
            }

            // Create result matrix positions (leftRows x rightCols)
            const leftTopLeft = {
              x: Math.min(...leftMatrix.map((el) => +el.dataset.x)),
              y: Math.min(...leftMatrix.map((el) => +el.dataset.y)),
            };

            let currentResultRow = 0;
            let currentResultCol = 0;

            moveMatrix(leftMatrix, rightMatrix);

            function animateNextDotProduct() {
              if (currentResultRow >= leftRows) {
                // All dot products complete, reset all opacities and update cluster labels
                // Reset all left matrix opacities
                for (let row = 0; row < leftRows; row++) {
                  resetRowOpacity(row);
                }
                // Reset all right matrix opacities
                for (let col = 0; col < rightCols; col++) {
                  resetColumnOpacity(col);
                }

                moveMatrix(leftMatrix, rightMatrix, false);
                renderClusterLabels();
                saveHistory(); //SAVE MATRIX HISTORY FOR UNDO*****************
                return;
              }

              if (currentResultCol >= rightCols) {
                // Row completed - move both left and right matrices down
                if (currentResultRow < leftRows - 1) {
                  // Don't move after the last row
                  moveMatrix(leftMatrix, rightMatrix);
                }

                // Lower opacity for the completed row
                lowerRowOpacity(currentResultRow);

                // Reset opacity for ALL columns of the right matrix when moving to next row
                for (let col = 0; col < rightCols; col++) {
                  resetColumnOpacity(col);
                }

                // Move to next row
                currentResultRow++;
                currentResultCol = 0;
                console.log("NEXT ROW");
                setTimeout(animateNextDotProduct, 400);
                return;
              }

              // Starting a new column - reset opacity for the current left row
              // (so the row can be processed again with the new column)
              resetLeftRowOpacity(currentResultRow);

              // Calculate final result position for this dot product
              const finalResultX =
                leftTopLeft.x + currentResultCol * (SIZE + GAP);
              const finalResultY =
                leftTopLeft.y +
                currentResultRow * (SIZE + GAP) -
                (SIZE + GAP) * 2;

              // Arrays to store the intermediate multiplication results
              const multiplicationResults = [];
              let elementPairIndex = 0;

              function animateNextMultiplication() {
                if (elementPairIndex >= leftCols) {
                  // All multiplications for this dot product are done
                  // Now combine the results into one final block
                  combineMultiplicationResults();
                  console.log("COMBINE");
                  return;
                }

                const leftElement =
                  leftGrid[currentResultRow][elementPairIndex].el;
                console.log("left:", currentResultRow, elementPairIndex);
                const rightElement =
                  rightGrid[elementPairIndex][currentResultCol].el;
                console.log("right:", elementPairIndex, currentResultCol);
                console.log(" ");

                // Create copies of both elements
                const leftCopy = createCopyOfElement(
                  leftElement,
                  parseFloat(leftElement.dataset.x),
                  parseFloat(leftElement.dataset.y)
                );
                const rightCopy = createCopyOfElement(
                  rightElement,
                  parseFloat(rightElement.dataset.x),
                  parseFloat(rightElement.dataset.y)
                );

                // Add transition classes
                leftCopy.classList.add("group-transition");
                rightCopy.classList.add("group-transition");

                // Force reflow
                leftCopy.offsetWidth;

                // Find the y of the top row of the left matrix
                const topRowY = leftMatrix[0].dataset.y;
                const upwardY = topRowY - (SIZE + GAP * 2);

                leftCopy.style.top = upwardY + "px";
                leftCopy.dataset.y = upwardY;

                rightCopy.style.top = upwardY + "px";
                rightCopy.dataset.y = upwardY;

                // Step 2: Move right copy to left copy position
                setTimeout(() => {
                  rightCopy.style.left = leftCopy.dataset.x + "px";
                  rightCopy.dataset.x = leftCopy.dataset.x;

                  // Step 3: Perform multiplication
                  setTimeout(() => {
                    const leftInput = leftCopy.querySelector("input.box-input");
                    const rightInput =
                      rightCopy.querySelector("input.box-input");

                    const leftVal = parseFloat(leftInput.value) || 0;
                    const rightVal = parseFloat(rightInput.value) || 0;
                    const product = leftVal * rightVal;

                    // Update left copy with the product and position it for intermediate result
                    leftInput.value = product;

                    // Show floating multiplication symbol
                    const symbolX = parseFloat(leftCopy.dataset.x) + SIZE / 2;
                    const symbolY = parseFloat(leftCopy.dataset.y);
                    createFloatingOperationSymbol(
                      symbolX,
                      symbolY,
                      false,
                      false
                    ); // false for multiplication

                    // Lower opacity of the original elements after copying
                    rightElement.style.opacity = "0.3";
                    leftElement.style.opacity = "0.3";

                    // Remove right copy and store left copy as intermediate result
                    rightCopy.remove();
                    multiplicationResults.push(leftCopy);

                    // Remove transition classes
                    leftCopy.classList.remove("group-transition");

                    // Move to next multiplication
                    elementPairIndex++;
                    setTimeout(animateNextMultiplication, 300);
                  }, 300);
                }, 300);
              }

              function combineMultiplicationResults() {
                if (multiplicationResults.length === 0) return;

                // Move all intermediate results to final position and add them up
                let finalSum = 0;
                const finalResultElement = multiplicationResults[0];

                // Calculate the sum
                multiplicationResults.forEach((resultEl) => {
                  const input = resultEl.querySelector("input.box-input");
                  finalSum += parseFloat(input.value) || 0;
                });

                // Animate all results moving to final position
                multiplicationResults.forEach((resultEl, index) => {
                  resultEl.classList.add("group-transition");

                  setTimeout(() => {
                    resultEl.style.left = finalResultX + "px";
                    resultEl.style.top = finalResultY + "px";
                    resultEl.dataset.x = finalResultX;
                    resultEl.dataset.y = finalResultY;

                    setTimeout(() => {
                      if (index === 0) {
                        // First element becomes the final result
                        const input = resultEl.querySelector("input.box-input");
                        input.value = finalSum;

                        // Show floating addition symbol when combining results (only if more than 1 result)
                        if (multiplicationResults.length > 1) {
                          const symbolX =
                            parseFloat(resultEl.dataset.x) + SIZE / 2;
                          const symbolY = parseFloat(resultEl.dataset.y) + SIZE;
                          createFloatingOperationSymbol(
                            symbolX,
                            symbolY,
                            true,
                            true
                          ); // true for addition
                        }

                        resultEl.classList.remove("group-transition");
                      } else {
                        // Remove other elements
                        resultEl.remove();
                      }

                      // If this was the last element, move to next dot product
                      if (index === multiplicationResults.length - 1) {
                        currentResultCol++;
                        setTimeout(animateNextDotProduct, 300);
                      }
                    }, 300);
                  }, index * 100); // Stagger the movement slightly
                });
              }

              // Start the multiplication sequence for this dot product
              animateNextMultiplication();
            }

            // Start the animation sequence
            animateNextDotProduct();
          });
      });
    </script>
  </body>
</html>
